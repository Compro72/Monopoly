<!DOCTYPE html>
<html>

<head>

<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

<title>Monopoly</title>

<!-- Babylon.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.6.2/dat.gui.min.js"></script>
<script src="https://assets.babylonjs.com/generated/Assets.js"></script>
<script src="https://cdn.babylonjs.com/recast.js"></script>
<script src="https://cdn.babylonjs.com/ammo.js"></script>
<script src="https://cdn.babylonjs.com/havok/HavokPhysics_umd.js"></script>
<script src="https://cdn.babylonjs.com/cannon.js"></script>
<script src="https://cdn.babylonjs.com/Oimo.js"></script>
<script src="https://cdn.babylonjs.com/earcut.min.js"></script>
<script src="https://cdn.babylonjs.com/babylon.js"></script>
<script src="https://cdn.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
<script src="https://cdn.babylonjs.com/proceduralTexturesLibrary/babylonjs.proceduralTextures.min.js"></script>
<script src="https://cdn.babylonjs.com/postProcessesLibrary/babylonjs.postProcess.min.js"></script>
<script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.js"></script>
<script src="https://cdn.babylonjs.com/serializers/babylonjs.serializers.min.js"></script>
<script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
<script src="https://cdn.babylonjs.com/inspector/babylon.inspector.bundle.js"></script>

<style>

html,

body {
	overflow: hidden;
        width: 100%;
        height: 100%;
        margin: 0;
        padding: 0;
}

#renderCanvas {
	width: 100%;
        height: 100%;
        touch-action: none;
}

#canvasZone {
        width: 100%;
        height: 100%;
}

</style>

</head>

<body>

<div id="canvasZone">
<canvas id="renderCanvas"></canvas>
</div>

<script>
	 
const canvas = document.getElementById("renderCanvas");
const engine = new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true, disableWebGL2Support: false });


let box1;
let box2;
let box1Rotation;
let box2Rotation;
let prevPosX, prevPosY, prevPosZ, prevRotX, prevRotY, prevRotZ;
let done = 0;

const roundNearest = (value, nearest) => Math.round(value / nearest) * nearest;
		
const createScene = async function () {
	// Babylon Scene--------------------------------------------------------------------------------------------
	const scene = new BABYLON.Scene(engine);

	
	// Camera---------------------------------------------------------------------------------------------------
	const camera = new BABYLON.ArcRotateCamera("camera", -Math.PI / 2, Math.PI / 2.5, 10, new BABYLON.Vector3(0, 0, 0));
  	camera.attachControl(canvas, true);

	
	// Light---------------------------------------------------------------------------------------------------
	let light1 = new BABYLON.DirectionalLight("light", new BABYLON.Vector3(-1, -2, -1), scene);
	light1.position = new BABYLON.Vector3(0, 40, 20);
	light1.intensity = 1;
	light1.shadowMaxZ = 130;
	light1.shadowMinZ = 10;

	let light2 = new BABYLON.HemisphericLight("HemiLight", new BABYLON.Vector3(0, 1, 0), scene);

	
	// Board----------------------------------------------------------------------------------------------------
	const groundMat = new BABYLON.StandardMaterial("groundMat");
	groundMat.diffuseTexture = new BABYLON.Texture("https://miro.medium.com/v2/resize:fit:1200/1*vBf3JmpboL86C1Q12ZECjw.jpeg");

	let ground = BABYLON.MeshBuilder.CreateGround("ground", {width:10, height:10});
	ground.material = groundMat;

	
	// Dice-------------------------------------------------------------------------------------------------------
	const mat = new BABYLON.StandardMaterial("mat");
	const texture = new BABYLON.Texture("diceNumbers.png");
	mat.diffuseTexture = texture;

	var columns = 6;
	var rows = 1;

	const faceUV = new Array(6);

	for (i = 0; i < 6; i++) {
		faceUV[i] = new BABYLON.Vector4(i / columns, 0, (i + 1) / columns, 1 / rows);
	}

	const options = {
		faceUV: faceUV,
		wrap: true,
		size: 0.25
	};

	box1 = BABYLON.MeshBuilder.CreateBox("box", options, scene);
	box1.material = mat;
	box1.position.x = 2;
	box1.position.y = Math.floor(Math.random() * (5 - 5 + 1)) + 5;
	box1.position.y = Math.floor(Math.random() * (8 - 4 + 1)) + 4;
	box1.rotation.x = Math.floor(Math.random() * (Math.PI - -Math.PI + 1)) + -Math.PI;
	box1.rotation.y = Math.floor(Math.random() * (Math.PI - -Math.PI + 1)) + -Math.PI;
	box1.rotation.z = Math.floor(Math.random() * (Math.PI - -Math.PI + 1)) + -Math.PI;


	box2 = BABYLON.MeshBuilder.CreateBox("box", options, scene);
	box2.material = mat;
	box2.position.x = 2;
	box2.position.y = Math.floor(Math.random() * (5 - 5 + 1)) + 5;
	box2.position.y = Math.floor(Math.random() * (8 - 4 + 1)) + 4;
	box2.rotation.x = Math.floor(Math.random() * (Math.PI - -Math.PI + 1)) + -Math.PI;
	box2.rotation.y = Math.floor(Math.random() * (Math.PI - -Math.PI + 1)) + -Math.PI;
	box2.rotation.z = Math.floor(Math.random() * (Math.PI - -Math.PI + 1)) + -Math.PI;


	// Shadows---------------------------------------------------------------------------------------------------
	var shadowGenerator = new BABYLON.ShadowGenerator(1024, light1);
	shadowGenerator.useContactHardeningShadow = true;
	shadowGenerator.setDarkness(0.25);
	shadowGenerator.addShadowCaster(box1);
	shadowGenerator.addShadowCaster(box2);
	shadowGenerator.useExponentialShadowMap = true;

	ground.receiveShadows = true;

	
	// initialize plugin-----------------------------------------------------------------------------------------
	const havokInstance = await HavokPhysics();
	// pass the engine to the plugin
	const hk = new BABYLON.HavokPlugin(true, havokInstance);
	// enable physics in the scene with a gravity
   	scene.enablePhysics(new BABYLON.Vector3(0, -9.8, 0), hk);
	
	// Create a box shape and the associated body. Size will be determined automatically.
	const box1Aggregate = new BABYLON.PhysicsAggregate(box1, BABYLON.PhysicsShapeType.BOX, { mass: 1, restitution: 0.75 }, scene);
	const box2Aggregate = new BABYLON.PhysicsAggregate(box2, BABYLON.PhysicsShapeType.BOX, { mass: 1, restitution: 0.75 }, scene);

	// Create a static plane shape.
	const groundAggregate = new BABYLON.PhysicsAggregate(ground, BABYLON.PhysicsShapeType.BOX, { mass: 0 }, scene);

	return scene;
};

createScene().then((scene) => {
	engine.runRenderLoop(function () {
		if (scene) {
			scene.render();
		}
		box1Rotation = box1.rotationQuaternion.toEulerAngles();
		if(prevPosX === box1.position.x && prevPosY === box1.position.y && prevPosZ === box1.position.z && prevRotX === rotation.x && prevRotY === rotation.y && prevRotZ === rotation.z && done==0) {
			if(Math.round(box1Rotation.x*100)/100 == -1.57 && Math.round(box1Rotation.z*100)/100 == 0) {
				window.alert("1");
				done++
			} else if(Math.round(box1Rotation.x*100)/100 == 1.57 && Math.round(box1Rotation.z*100)/100 == 0) {
				window.alert("2");
				done++
			} else if(Math.round(box1Rotation.x*100)/100 == 0 && Math.round(box1Rotation.z*100)/100 == 1.57) {
				window.alert("3");
				done++
			} else if(Math.round(box1Rotation.x*100)/100 == 0 && Math.round(box1Rotation.z*100)/100 == -1.57) {
				window.alert("4");
				done++
			} else if(Math.round(box1Rotation.x*100)/100 == 0 && Math.round(box1Rotation.z*100)/100 == 0) {
				window.alert("5");
				done++
			} else if(Math.round(box1Rotation.x*100)/100 == 0 && Math.round(box1Rotation.z*100)/100 == 3.14||-3.14) {
				window.alert("6");
				done++
			}
		}
		prevPosX = box1.position.x;
		prevPosY = box1.position.y;
		prevPosZ = box1.position.z;
		prevRotX = box1Rotation.x;
		prevRotY = box1Rotation.y;
		prevRotZ = box1Rotation.z;
	});
});

// Resize
window.addEventListener("resize", function () {
	engine.resize();
});
	
</script>
	
</body>

</html>