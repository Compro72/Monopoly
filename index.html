<!DOCTYPE html>
<html>

<head>

<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

<title>Monopoly</title>

<!-- Babylon.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.6.2/dat.gui.min.js"></script>
<script src="https://assets.babylonjs.com/generated/Assets.js"></script>
<script src="https://cdn.babylonjs.com/recast.js"></script>
<script src="https://cdn.babylonjs.com/ammo.js"></script>
<script src="https://cdn.babylonjs.com/havok/HavokPhysics_umd.js"></script>
<script src="https://cdn.babylonjs.com/cannon.js"></script>
<script src="https://cdn.babylonjs.com/Oimo.js"></script>
<script src="https://cdn.babylonjs.com/earcut.min.js"></script>
<script src="https://cdn.babylonjs.com/babylon.js"></script>
<script src="https://cdn.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
<script src="https://cdn.babylonjs.com/proceduralTexturesLibrary/babylonjs.proceduralTextures.min.js"></script>
<script src="https://cdn.babylonjs.com/postProcessesLibrary/babylonjs.postProcess.min.js"></script>
<script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.js"></script>
<script src="https://cdn.babylonjs.com/serializers/babylonjs.serializers.min.js"></script>
<script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
<script src="https://cdn.babylonjs.com/inspector/babylon.inspector.bundle.js"></script>

<style>

html,

body {
	overflow: hidden;
        width: 100%;
        height: 100%;
        margin: 0;
        padding: 0;
}

#renderCanvas {
	width: 100%;
        height: 100%;
        touch-action: none;
}

#canvasZone {
        width: 100%;
        height: 100%;
}

</style>

</head>

<body>

<div id="canvasZone">
<canvas id="renderCanvas"></canvas>
</div>

<script>
	 
const canvas = document.getElementById("renderCanvas");
const engine = new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true, disableWebGL2Support: false });


let box1;
let box2;
let box1Rotation, dice1Val;
let box2Rotation, dice2Val;
let prevBox1PosX, prevBox1PosY, prevBox1PosZ, prevBox1RotX, prevBox1RotY, prevBox1RotZ;
let prevBox2PosX, prevBox2PosY, prevBox2PosZ, prevBox2RotX, prevBox2RotY, prevBox2RotZ;
let done = 0;
let total;

const roundNearest = (value, nearest) => Math.round(value / nearest) * nearest;
		
const createScene = async function () {
	// Babylon Scene--------------------------------------------------------------------------------------------
	const scene = new BABYLON.Scene(engine);

	
	// Camera---------------------------------------------------------------------------------------------------
	const camera = new BABYLON.ArcRotateCamera("camera", -Math.PI / 2, Math.PI / 2.5, 10, new BABYLON.Vector3(0, 0, 0));
  	camera.attachControl(canvas, true);

	
	// Light---------------------------------------------------------------------------------------------------
	let light1 = new BABYLON.DirectionalLight("light", new BABYLON.Vector3(-1, -2, -1), scene);
	light1.position = new BABYLON.Vector3(0, 40, 20);
	light1.intensity = 1;
	light1.shadowMaxZ = 130;
	light1.shadowMinZ = 10;

	let light2 = new BABYLON.HemisphericLight("HemiLight", new BABYLON.Vector3(0, 1, 0), scene);

	
	// Board----------------------------------------------------------------------------------------------------
	const groundMat = new BABYLON.StandardMaterial("groundMat");
	groundMat.diffuseTexture = new BABYLON.Texture("https://miro.medium.com/v2/resize:fit:1200/1*vBf3JmpboL86C1Q12ZECjw.jpeg");

	let ground = BABYLON.MeshBuilder.CreateGround("ground", {width:10, height:10});
	ground.material = groundMat;

	
	// Dice-------------------------------------------------------------------------------------------------------
	
	// Dice Texture
	const mat = new BABYLON.StandardMaterial("mat");
	const texture = new BABYLON.Texture("diceNumbers.png");
	mat.diffuseTexture = texture;
	var columns = 6;
	var rows = 1;
	const faceUV = new Array(6);
	for (i = 0; i < 6; i++) {
		faceUV[i] = new BABYLON.Vector4(i / columns, 0, (i + 1) / columns, 1 / rows);
	}

	// Set Options
	const options = {
		faceUV: faceUV,
		wrap: true,
		size: 0.25
	};

	// Dice 1
	box1 = BABYLON.MeshBuilder.CreateBox("box", options, scene);
	box1.material = mat;
	box1.position.y = Math.floor(Math.random() * (5 - 5 + 1)) + 5;
	box1.position.y = Math.floor(Math.random() * (8 - 4 + 1)) + 4;
	box1.rotation.x = Math.floor(Math.random() * (Math.PI - -Math.PI + 1)) + -Math.PI;
	box1.rotation.y = Math.floor(Math.random() * (Math.PI - -Math.PI + 1)) + -Math.PI;
	box1.rotation.z = Math.floor(Math.random() * (Math.PI - -Math.PI + 1)) + -Math.PI;


	// Dice 2
	box2 = BABYLON.MeshBuilder.CreateBox("box", options, scene);
	box2.material = mat;
	box2.position.y = Math.floor(Math.random() * (5 - 5 + 1)) + 5;
	box2.position.y = Math.floor(Math.random() * (8 - 4 + 1)) + 4;
	box2.rotation.x = Math.floor(Math.random() * (Math.PI - -Math.PI + 1)) + -Math.PI;
	box2.rotation.y = Math.floor(Math.random() * (Math.PI - -Math.PI + 1)) + -Math.PI;
	box2.rotation.z = Math.floor(Math.random() * (Math.PI - -Math.PI + 1)) + -Math.PI;


	// Shadows---------------------------------------------------------------------------------------------------
	var shadowGenerator = new BABYLON.ShadowGenerator(1024, light1);
	shadowGenerator.useContactHardeningShadow = true;
	shadowGenerator.setDarkness(0.25);
	shadowGenerator.addShadowCaster(box1);
	shadowGenerator.addShadowCaster(box2);
	shadowGenerator.useExponentialShadowMap = true;

	ground.receiveShadows = true;

	
	// initialize plugin-----------------------------------------------------------------------------------------
	const havokInstance = await HavokPhysics();
	// pass the engine to the plugin
	const hk = new BABYLON.HavokPlugin(true, havokInstance);
	// enable physics in the scene with a gravity
   	scene.enablePhysics(new BABYLON.Vector3(0, -9.8, 0), hk);
	
	// Create a box shape and the associated body. Size will be determined automatically.
	const box1Aggregate = new BABYLON.PhysicsAggregate(box1, BABYLON.PhysicsShapeType.BOX, { mass: 1, restitution: 0.75 }, scene);
	const box2Aggregate = new BABYLON.PhysicsAggregate(box2, BABYLON.PhysicsShapeType.BOX, { mass: 1, restitution: 0.75 }, scene);

	// Create a static plane shape.
	const groundAggregate = new BABYLON.PhysicsAggregate(ground, BABYLON.PhysicsShapeType.BOX, { mass: 0 }, scene);

	return scene;
};

createScene().then((scene) => {
	engine.runRenderLoop(function () {
		if (scene) {
			scene.render();
		}
		box1Rotation = box1.rotationQuaternion.toEulerAngles();
		box2Rotation = box2.rotationQuaternion.toEulerAngles();
		if(prevBox1PosX === box1.position.x && prevBox1PosY === box1.position.y && prevBox1PosZ === box1.position.z && prevBox1RotX === box1Rotation.x && prevBox1RotY === box1Rotation.y && prevBox1RotZ === box1Rotation.z && prevBox2PosX === box2.position.x && prevBox2PosY === box2.position.y && prevBox2PosZ === box2.position.z && prevBox2RotX === box2Rotation.x && prevBox2RotY === box2Rotation.y && prevBox2RotZ === box2Rotation.z && done==0) {
			// Check dice 1
			if(Math.round(box1Rotation.x*100)/100 == -1.57 && Math.round(box1Rotation.z*100)/100 == 0) {
				dice1Val = 1;
			} else if(Math.round(box1Rotation.x*100)/100 == 1.57 && Math.round(box1Rotation.z*100)/100 == 0) {
				dice1Val = 2;
			} else if(Math.round(box1Rotation.x*100)/100 == 0 && Math.round(box1Rotation.z*100)/100 == 1.57) {
				dice1Val = 3;
			} else if(Math.round(box1Rotation.x*100)/100 == 0 && Math.round(box1Rotation.z*100)/100 == -1.57) {
				dice1Val = 4;
			} else if(Math.round(box1Rotation.x*100)/100 == 0 && Math.round(box1Rotation.z*100)/100 == 0) {
				dice1Val = 5;
			} else if(Math.round(box1Rotation.x*100)/100 == 0 && Math.round(box1Rotation.z*100)/100 == 3.14||-3.14) {
				dice1Val = 6;
			}

			// Check dice 2
			if(Math.round(box2Rotation.x*100)/100 == -1.57 && Math.round(box2Rotation.z*100)/100 == 0) {
				dice2Val = 1;
			} else if(Math.round(box2Rotation.x*100)/100 == 1.57 && Math.round(box2Rotation.z*100)/100 == 0) {
				dice2Val = 2;
			} else if(Math.round(box2Rotation.x*100)/100 == 0 && Math.round(box2Rotation.z*100)/100 == 1.57) {
				dice2Val = 3;
			} else if(Math.round(box2Rotation.x*100)/100 == 0 && Math.round(box2Rotation.z*100)/100 == -1.57) {
				dice2Val = 4;
			} else if(Math.round(box2Rotation.x*100)/100 == 0 && Math.round(box2Rotation.z*100)/100 == 0) {
				dice2Val = 5;
			} else if(Math.round(box2Rotation.x*100)/100 == 0 && Math.round(box2Rotation.z*100)/100 == 3.14||-3.14) {
				dice2Val = 6;
			}

			total = dice1Val + dice2Val;
			window.alert(dice1Val + "+" + dice2Val + "=" + total)
			done++
		}
		prevBox1PosX = box1.position.x;
		prevBox1PosY = box1.position.y;
		prevBox1PosZ = box1.position.z;
		prevBox1RotX = box1Rotation.x;
		prevBox1RotY = box1Rotation.y;
		prevBox1RotZ = box1Rotation.z;

		prevBox2PosX = box2.position.x;
		prevBox2PosY = box2.position.y;
		prevBox2PosZ = box2.position.z;
		prevBox2RotX = box2Rotation.x;
		prevBox2RotY = box2Rotation.y;
		prevBox2RotZ = box2Rotation.z;

		console.log(box1Rotation, box2Rotation)
	});
});

// Resize
window.addEventListener("resize", function () {
	engine.resize();
});
	
</script>
	
</body>

</html>