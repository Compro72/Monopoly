<!DOCTYPE html>
<html>

<head>

<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

<title>Monopoly</title>

<!-- Babylon.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.6.2/dat.gui.min.js"></script>
<script src="https://assets.babylonjs.com/generated/Assets.js"></script>
<script src="https://cdn.babylonjs.com/recast.js"></script>
<script src="https://cdn.babylonjs.com/ammo.js"></script>
<script src="https://cdn.babylonjs.com/havok/HavokPhysics_umd.js"></script>
<script src="https://cdn.babylonjs.com/cannon.js"></script>
<script src="https://cdn.babylonjs.com/Oimo.js"></script>
<script src="https://cdn.babylonjs.com/earcut.min.js"></script>
<script src="https://cdn.babylonjs.com/babylon.js"></script>
<script src="https://cdn.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
<script src="https://cdn.babylonjs.com/proceduralTexturesLibrary/babylonjs.proceduralTextures.min.js"></script>
<script src="https://cdn.babylonjs.com/postProcessesLibrary/babylonjs.postProcess.min.js"></script>
<script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.js"></script>
<script src="https://cdn.babylonjs.com/serializers/babylonjs.serializers.min.js"></script>
<script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
<script src="https://cdn.babylonjs.com/inspector/babylon.inspector.bundle.js"></script>

<style>

html, body {
	overflow: hidden;
	width: 100%;
	height: 100%;
	margin: 0;
	padding: 0;
}

#renderCanvas {
	width: 100%;
	height: 100%;
	touch-action: none;
}
            
#canvasZone {
	width: 100%;
	height: 100%;
}

</style>

</head>


<body>

<div id="canvasZone">
<canvas id="renderCanvas"></canvas>
</div>

<script>

var canvas = document.getElementById("renderCanvas");
let boxMeshes=[], boxes=[];

initCannon();

let startRenderLoop = function (engine, canvas) {
	engine.runRenderLoop(function () {
		if (sceneToRender && sceneToRender.activeCamera) {
			sceneToRender.render();
		}
	});
	for(i=0; i<boxes.length; i++){
      		boxMeshes[i].position.copy(boxes[i].position);
      		boxMeshes[i].quaternion.copy(boxes[i].quaternion);
	}
}


var engine = null;
var scene = null;
var sceneToRender = null;


let createDefaultEngine = function() { return new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true,  disableWebGL2Support: false}); 
};


const createScene =  () => {
	let i;
	const scene = new BABYLON.Scene(engine);

	scene.enablePhysics(new BABYLON.Vector3(0,-30,0), new BABYLON.CannonJSPlugin());

   /**** Set camera and light *****/
	const camera = new BABYLON.ArcRotateCamera("camera", -Math.PI / 2, Math.PI / 2.5, 10, new BABYLON.Vector3(0, 0, 0));
	camera.attachControl(canvas, true);
	const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(1, 1, 0));

	// Ground
	const groundMat = new BABYLON.StandardMaterial("groundMat");
	groundMat.diffuseTexture = new BABYLON.Texture("https://miro.medium.com/v2/resize:fit:1200/1*vBf3JmpboL86C1Q12ZECjw.jpeg");

	const ground = BABYLON.MeshBuilder.CreateGround("ground", {width:10, height:10});
	ground.material = groundMat;


	const mat = new BABYLON.StandardMaterial("mat");
	const texture = new BABYLON.Texture("diceNumbers.png");
	mat.diffuseTexture = texture;

	var columns = 6;
	var rows = 1;

	const faceUV = new Array(6);

	for (i = 0; i < 6; i++) {
		faceUV[i] = new BABYLON.Vector4(i / columns, 0, (i + 1) / columns, 1 / rows);
	}

	const options = {
		faceUV: faceUV,
		wrap: true,
		size: 0.25
	};

	const box = BABYLON.MeshBuilder.CreateBox("box", options);
	box.material = mat;
	box.position.y = 3;
	
	boxMeshes.push(box);
	
	BoxX = 0;
	BoxY = 2;
	BoxZ = 0;
	BoxSize = new CANNON.Vec3(2, 2, 2);
	BoxShape = new CANNON.Box(BoxSize);
	BoxBody = new CANNON.Body({ mass: 1000 });
	BoxBody.addShape(BoxShape);
	world.add(BoxBody);
	BoxBody.position.set(BoxX, BoxY, BoxZ);
	boxes.push(BoxBody);

	return scene;
}


function initCannon() {
// Setup our world
   world = new CANNON.World();
   world.quatNormalizeSkip = 0;
   world.quatNormalizeFast = false;

	let solver = new CANNON.GSSolver();

   world.defaultContactMaterial.contactEquationStiffness = 1e9;
   world.defaultContactMaterial.contactEquationRelaxation = 4;

   solver.iterations = 7;
   solver.tolerance = 0.1;
   let split = true;
   if(split)
      world.solver = new CANNON.SplitSolver(solver);
      else
      world.solver = solver;

   world.gravity.set(0,-20,0);
   world.broadphase = new CANNON.NaiveBroadphase();

   // Create a slippery material (friction coefficient = 0.0)
   physicsMaterial = new CANNON.Material("slipperyMaterial");
   let physicsContactMaterial = new CANNON.ContactMaterial(physicsMaterial,
                                                                        physicsMaterial,
                                                                        0.0, // friction coefficient
                                                                        0.3  // restitution
                                                                        );
   // We must add the contact materials to the world
   world.addContactMaterial(physicsContactMaterial);

   // Create a plane
   let groundShape = new CANNON.Plane();
   let groundBody = new CANNON.Body({ mass: 0 });
   groundBody.addShape(groundShape);
   groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1,0,0),-Math.PI/2);
   world.add(groundBody);
}
	

window.initFunction = async function() {
	var asyncEngineCreation = async function() {
   	try {
      	return createDefaultEngine();
		} catch(e) {
			console.log("the available createEngine function failed. Creating the default engine instead");
			return createDefaultEngine();
		}
	}
	window.engine = await asyncEngineCreation();
	if (!engine) throw 'engine should not be null.';
	startRenderLoop(engine, canvas);
	window.scene = createScene();
};


initFunction().then(() => {sceneToRender = scene});


// Resize
window.addEventListener("resize", function () {
	engine.resize();
});

</script>

</body>

</html>
